# ğŸ“ åŸºç¡€æ–‡ä»¶æ“ä½œåŠŸèƒ½è®¾è®¡

> **åŠŸèƒ½ä¼˜å…ˆçº§**: æœ€é«˜  
> **é¢„è®¡å¼€å‘æ—¶é—´**: Day 1-2  
> **ä¾èµ–**: æ— 

## ğŸ“‹ åŠŸèƒ½æ¦‚è¿°

å®ç° JetIDE çš„æ ¸å¿ƒæ–‡ä»¶ç®¡ç†åŠŸèƒ½ï¼ŒåŒ…æ‹¬æ–‡ä»¶/æ–‡ä»¶å¤¹çš„åˆ›å»ºã€åˆ é™¤ã€é‡å‘½åç­‰åŸºç¡€æ“ä½œã€‚è¿™æ˜¯æ•´ä¸ªç¼–è¾‘å™¨çš„åŸºç¡€åŠŸèƒ½ï¼Œå¿…é¡»ä¼˜å…ˆå®ç°ä»¥æ”¯æŒåç»­çš„å¼€å‘å’Œæµ‹è¯•ã€‚

## ğŸ¯ åŠŸèƒ½éœ€æ±‚

### æ ¸å¿ƒåŠŸèƒ½

- [ ] å³é”®èœå•æ˜¾ç¤º
- [ ] æ–°å»ºæ–‡ä»¶
- [ ] æ–°å»ºæ–‡ä»¶å¤¹
- [ ] åˆ é™¤æ–‡ä»¶/æ–‡ä»¶å¤¹
- [ ] é‡å‘½åæ–‡ä»¶/æ–‡ä»¶å¤¹
- [ ] å¤åˆ¶æ–‡ä»¶è·¯å¾„åˆ°å‰ªè´´æ¿
- [ ] åœ¨ç³»ç»Ÿæ–‡ä»¶ç®¡ç†å™¨ä¸­æ˜¾ç¤º

### ç”¨æˆ·ä½“éªŒ

- [ ] å†…è”ç¼–è¾‘æ”¯æŒ
- [ ] æ“ä½œç¡®è®¤å¯¹è¯æ¡†
- [ ] åŠ è½½çŠ¶æ€æŒ‡ç¤º
- [ ] é”™è¯¯æç¤º
- [ ] æ“ä½œæˆåŠŸåé¦ˆ

## ğŸ—ï¸ æ¶æ„è®¾è®¡

### æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   UI å±‚ (React)  â”‚  â† å³é”®èœå•ã€æ–‡ä»¶æ ‘ç»„ä»¶ã€å¯¹è¯æ¡†
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ¸²æŸ“è¿›ç¨‹ä¸šåŠ¡å±‚    â”‚  â† æ–‡ä»¶æ“ä½œé€»è¾‘ã€çŠ¶æ€ç®¡ç†ã€éªŒè¯
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   IPC é€šä¿¡å±‚     â”‚  â† preload è„šæœ¬å®‰å…¨æ¡¥æ¥
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ä¸»è¿›ç¨‹æ–‡ä»¶ç³»ç»Ÿå±‚  â”‚  â† Node.js fs æ¨¡å—ã€ç³»ç»Ÿé›†æˆ
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ•°æ®æµ

```
ç”¨æˆ·å³é”® â†’ æ˜¾ç¤ºèœå• â†’ é€‰æ‹©æ“ä½œ â†’ éªŒè¯è¾“å…¥ â†’ IPCè°ƒç”¨ â†’ ä¸»è¿›ç¨‹å¤„ç† â†’ è¿”å›ç»“æœ â†’ æ›´æ–°UI â†’ åˆ·æ–°æ–‡ä»¶æ ‘
```

## ğŸ¨ ç”¨æˆ·äº¤äº’è®¾è®¡

### å³é”®èœå•è®¾è®¡

#### æ–‡ä»¶å³é”®èœå•

```
ğŸ“„ æ–‡ä»¶å.txt
â”œâ”€â”€ âœï¸ é‡å‘½å
â”œâ”€â”€ ğŸ—‘ï¸ åˆ é™¤
â”œâ”€â”€ ğŸ“‹ å¤åˆ¶è·¯å¾„
â””â”€â”€ ğŸ” åœ¨æ–‡ä»¶ç®¡ç†å™¨ä¸­æ˜¾ç¤º
```

#### æ–‡ä»¶å¤¹å³é”®èœå•

```
ğŸ“ æ–‡ä»¶å¤¹å
â”œâ”€â”€ ğŸ“„ æ–°å»ºæ–‡ä»¶
â”œâ”€â”€ ğŸ“ æ–°å»ºæ–‡ä»¶å¤¹
â”œâ”€â”€ âœï¸ é‡å‘½å
â”œâ”€â”€ ğŸ—‘ï¸ åˆ é™¤
â”œâ”€â”€ ğŸ“‹ å¤åˆ¶è·¯å¾„
â”œâ”€â”€ ğŸ” åœ¨æ–‡ä»¶ç®¡ç†å™¨ä¸­æ˜¾ç¤º
â””â”€â”€ ğŸ”„ åˆ·æ–°
```

#### ç©ºç™½åŒºåŸŸå³é”®èœå•

```
ğŸ“ å½“å‰ç›®å½•
â”œâ”€â”€ ğŸ“„ æ–°å»ºæ–‡ä»¶
â”œâ”€â”€ ğŸ“ æ–°å»ºæ–‡ä»¶å¤¹
â””â”€â”€ ğŸ”„ åˆ·æ–°
```

### äº¤äº’æµç¨‹

#### æ–°å»ºæ–‡ä»¶/æ–‡ä»¶å¤¹æµç¨‹

1. ç”¨æˆ·å³é”®é€‰æ‹©"æ–°å»ºæ–‡ä»¶"æˆ–"æ–°å»ºæ–‡ä»¶å¤¹"
2. åœ¨æ–‡ä»¶æ ‘ä¸­æ˜¾ç¤ºå†…è”ç¼–è¾‘å™¨ï¼Œé»˜è®¤åç§°ä¸º"æ–°å»ºæ–‡ä»¶.txt"æˆ–"æ–°å»ºæ–‡ä»¶å¤¹"
3. ç”¨æˆ·è¾“å…¥åç§°ï¼ŒæŒ‰ Enter ç¡®è®¤æˆ– Esc å–æ¶ˆ
4. éªŒè¯æ–‡ä»¶ååˆæ³•æ€§
5. æ£€æŸ¥æ˜¯å¦å­˜åœ¨åŒåæ–‡ä»¶ï¼Œå¦‚å­˜åœ¨åˆ™æç¤ºç”¨æˆ·
6. åˆ›å»ºæ–‡ä»¶/æ–‡ä»¶å¤¹å¹¶åˆ·æ–°æ–‡ä»¶æ ‘
7. é«˜äº®æ˜¾ç¤ºæ–°åˆ›å»ºçš„é¡¹ç›®

#### é‡å‘½åæµç¨‹

1. ç”¨æˆ·å³é”®é€‰æ‹©"é‡å‘½å"
2. å½“å‰æ–‡ä»¶åå˜ä¸ºå¯ç¼–è¾‘çŠ¶æ€ï¼Œæ–‡æœ¬è¢«é€‰ä¸­
3. ç”¨æˆ·ä¿®æ”¹åç§°ï¼ŒæŒ‰ Enter ç¡®è®¤æˆ– Esc å–æ¶ˆ
4. éªŒè¯æ–°æ–‡ä»¶ååˆæ³•æ€§
5. æ£€æŸ¥æ˜¯å¦å­˜åœ¨åŒåæ–‡ä»¶
6. æ‰§è¡Œé‡å‘½åæ“ä½œå¹¶åˆ·æ–°æ–‡ä»¶æ ‘

#### åˆ é™¤æµç¨‹

1. ç”¨æˆ·å³é”®é€‰æ‹©"åˆ é™¤"
2. æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†ï¼š"ç¡®å®šè¦åˆ é™¤ [æ–‡ä»¶å] å—ï¼Ÿ"
3. ç”¨æˆ·ç¡®è®¤åæ‰§è¡Œåˆ é™¤æ“ä½œ
4. å¦‚æœåˆ é™¤çš„æ–‡ä»¶å½“å‰åœ¨ç¼–è¾‘å™¨ä¸­æ‰“å¼€ï¼Œåˆ™å…³é—­å¯¹åº”æ ‡ç­¾é¡µ
5. åˆ·æ–°æ–‡ä»¶æ ‘

## ğŸ”§ æŠ€æœ¯å®ç°

### ç±»å‹å®šä¹‰

```typescript
// src/shared/types.ts

interface FileOperationResult {
  success: boolean
  error?: string
  data?: any
}

interface CreateFileRequest {
  parentPath: string
  fileName: string
  isDirectory: boolean
}

interface RenameRequest {
  oldPath: string
  newPath: string
}

interface DeleteRequest {
  path: string
  isDirectory: boolean
}

interface ContextMenuPosition {
  x: number
  y: number
}

interface ContextMenuItem {
  id: string
  label: string
  icon: string
  disabled?: boolean
  separator?: boolean
}
```

### IPC æ¥å£è®¾è®¡

```typescript
// src/main/ipc/fileOperations.ts

export const fileOperationHandlers = {
  'file:create': async (
    event,
    request: CreateFileRequest
  ): Promise<FileOperationResult> => {
    // å®ç°æ–‡ä»¶åˆ›å»ºé€»è¾‘
  },

  'file:delete': async (
    event,
    request: DeleteRequest
  ): Promise<FileOperationResult> => {
    // å®ç°æ–‡ä»¶åˆ é™¤é€»è¾‘
  },

  'file:rename': async (
    event,
    request: RenameRequest
  ): Promise<FileOperationResult> => {
    // å®ç°æ–‡ä»¶é‡å‘½åé€»è¾‘
  },

  'file:copy-path': async (event, path: string): Promise<void> => {
    // å¤åˆ¶è·¯å¾„åˆ°å‰ªè´´æ¿
  },

  'file:show-in-explorer': async (event, path: string): Promise<void> => {
    // åœ¨ç³»ç»Ÿæ–‡ä»¶ç®¡ç†å™¨ä¸­æ˜¾ç¤º
  },
}
```

### ä¸»è¿›ç¨‹æ–‡ä»¶æœåŠ¡

```typescript
// src/main/services/fileService.ts

import * as fs from 'fs/promises'
import * as path from 'path'
import { shell, clipboard } from 'electron'

export class FileService {
  async createFile(
    parentPath: string,
    fileName: string
  ): Promise<FileOperationResult> {
    try {
      const fullPath = path.join(parentPath, fileName)

      // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²å­˜åœ¨
      if (await this.exists(fullPath)) {
        return { success: false, error: 'æ–‡ä»¶å·²å­˜åœ¨' }
      }

      // åˆ›å»ºæ–‡ä»¶
      await fs.writeFile(fullPath, '', 'utf8')

      return { success: true, data: { path: fullPath } }
    } catch (error) {
      return { success: false, error: error.message }
    }
  }

  async createDirectory(
    parentPath: string,
    dirName: string
  ): Promise<FileOperationResult> {
    try {
      const fullPath = path.join(parentPath, dirName)

      if (await this.exists(fullPath)) {
        return { success: false, error: 'æ–‡ä»¶å¤¹å·²å­˜åœ¨' }
      }

      await fs.mkdir(fullPath, { recursive: true })

      return { success: true, data: { path: fullPath } }
    } catch (error) {
      return { success: false, error: error.message }
    }
  }

  async deleteItem(itemPath: string): Promise<FileOperationResult> {
    try {
      const stats = await fs.stat(itemPath)

      if (stats.isDirectory()) {
        await fs.rmdir(itemPath, { recursive: true })
      } else {
        await fs.unlink(itemPath)
      }

      return { success: true }
    } catch (error) {
      return { success: false, error: error.message }
    }
  }

  async renameItem(
    oldPath: string,
    newPath: string
  ): Promise<FileOperationResult> {
    try {
      if (await this.exists(newPath)) {
        return { success: false, error: 'ç›®æ ‡æ–‡ä»¶å·²å­˜åœ¨' }
      }

      await fs.rename(oldPath, newPath)

      return { success: true, data: { newPath } }
    } catch (error) {
      return { success: false, error: error.message }
    }
  }

  async copyPathToClipboard(itemPath: string): Promise<void> {
    clipboard.writeText(itemPath)
  }

  async showInFileManager(itemPath: string): Promise<void> {
    shell.showItemInFolder(itemPath)
  }

  private async exists(path: string): Promise<boolean> {
    try {
      await fs.access(path)
      return true
    } catch {
      return false
    }
  }
}
```

### çŠ¶æ€ç®¡ç†

```typescript
// src/renderer/store/fileOperationStore.ts

import { create } from 'zustand'

interface FileOperationState {
  // çŠ¶æ€
  isLoading: boolean
  currentOperation: string | null
  error: string | null

  // UI çŠ¶æ€
  contextMenu: {
    visible: boolean
    x: number
    y: number
    target: FileSystemItem | null
  }

  editingItem: string | null

  // Actions
  showContextMenu: (x: number, y: number, target: FileSystemItem) => void
  hideContextMenu: () => void

  startEditing: (path: string) => void
  stopEditing: () => void

  createFile: (parentPath: string, fileName: string) => Promise<void>
  createDirectory: (parentPath: string, dirName: string) => Promise<void>
  deleteItem: (path: string) => Promise<void>
  renameItem: (oldPath: string, newPath: string) => Promise<void>
  copyPath: (path: string) => Promise<void>
  showInExplorer: (path: string) => Promise<void>
}

export const useFileOperationStore = create<FileOperationState>((set, get) => ({
  // åˆå§‹çŠ¶æ€
  isLoading: false,
  currentOperation: null,
  error: null,
  contextMenu: {
    visible: false,
    x: 0,
    y: 0,
    target: null,
  },
  editingItem: null,

  // UI Actions
  showContextMenu: (x, y, target) => {
    set({
      contextMenu: { visible: true, x, y, target },
    })
  },

  hideContextMenu: () => {
    set({
      contextMenu: { visible: false, x: 0, y: 0, target: null },
    })
  },

  startEditing: path => {
    set({ editingItem: path })
  },

  stopEditing: () => {
    set({ editingItem: null })
  },

  // æ–‡ä»¶æ“ä½œ Actions
  createFile: async (parentPath, fileName) => {
    set({ isLoading: true, currentOperation: 'creating-file', error: null })

    try {
      const result = await window.electronAPI.invoke('file:create', {
        parentPath,
        fileName,
        isDirectory: false,
      })

      if (!result.success) {
        throw new Error(result.error)
      }

      // åˆ·æ–°æ–‡ä»¶æ ‘
      await useAppStore.getState().loadFileTree(parentPath)
    } catch (error) {
      set({ error: error.message })
    } finally {
      set({ isLoading: false, currentOperation: null })
    }
  },

  // ... å…¶ä»–æ“ä½œç±»ä¼¼å®ç°
}))
```

### UI ç»„ä»¶

#### å³é”®èœå•ç»„ä»¶

```typescript
// src/renderer/components/ContextMenu.tsx

import React, { useEffect, useRef } from 'react'
import { useFileOperationStore } from '../store/fileOperationStore'

export const ContextMenu: React.FC = () => {
  const menuRef = useRef<HTMLDivElement>(null)
  const {
    contextMenu,
    hideContextMenu,
    createFile,
    createDirectory,
    deleteItem,
    startEditing,
    copyPath,
    showInExplorer
  } = useFileOperationStore()

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        hideContextMenu()
      }
    }

    if (contextMenu.visible) {
      document.addEventListener('mousedown', handleClickOutside)
      return () => document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [contextMenu.visible, hideContextMenu])

  if (!contextMenu.visible || !contextMenu.target) {
    return null
  }

  const { target, x, y } = contextMenu

  const menuItems = getMenuItems(target)

  const handleAction = async (actionId: string) => {
    hideContextMenu()

    switch (actionId) {
      case 'new-file':
        await createFile(target.path, 'æ–°å»ºæ–‡ä»¶.txt')
        break
      case 'new-folder':
        await createDirectory(target.path, 'æ–°å»ºæ–‡ä»¶å¤¹')
        break
      case 'rename':
        startEditing(target.path)
        break
      case 'delete':
        if (confirm(`ç¡®å®šè¦åˆ é™¤ ${target.name} å—ï¼Ÿ`)) {
          await deleteItem(target.path)
        }
        break
      case 'copy-path':
        await copyPath(target.path)
        break
      case 'show-in-explorer':
        await showInExplorer(target.path)
        break
    }
  }

  return (
    <div
      ref={menuRef}
      className="fixed bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-md shadow-lg py-1 z-50"
      style={{ left: x, top: y }}
    >
      {menuItems.map((item, index) => (
        item.separator ? (
          <div key={index} className="border-t border-gray-200 dark:border-gray-700 my-1" />
        ) : (
          <button
            key={item.id}
            className="w-full text-left px-3 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 flex items-center gap-2"
            onClick={() => handleAction(item.id)}
            disabled={item.disabled}
          >
            <span>{item.icon}</span>
            <span>{item.label}</span>
          </button>
        )
      ))}
    </div>
  )
}

function getMenuItems(target: FileSystemItem): ContextMenuItem[] {
  if (target.isDirectory) {
    return [
      { id: 'new-file', label: 'æ–°å»ºæ–‡ä»¶', icon: 'ğŸ“„' },
      { id: 'new-folder', label: 'æ–°å»ºæ–‡ä»¶å¤¹', icon: 'ğŸ“' },
      { separator: true },
      { id: 'rename', label: 'é‡å‘½å', icon: 'âœï¸' },
      { id: 'delete', label: 'åˆ é™¤', icon: 'ğŸ—‘ï¸' },
      { separator: true },
      { id: 'copy-path', label: 'å¤åˆ¶è·¯å¾„', icon: 'ğŸ“‹' },
      { id: 'show-in-explorer', label: 'åœ¨æ–‡ä»¶ç®¡ç†å™¨ä¸­æ˜¾ç¤º', icon: 'ğŸ”' },
      { separator: true },
      { id: 'refresh', label: 'åˆ·æ–°', icon: 'ğŸ”„' }
    ]
  } else {
    return [
      { id: 'rename', label: 'é‡å‘½å', icon: 'âœï¸' },
      { id: 'delete', label: 'åˆ é™¤', icon: 'ğŸ—‘ï¸' },
      { separator: true },
      { id: 'copy-path', label: 'å¤åˆ¶è·¯å¾„', icon: 'ğŸ“‹' },
      { id: 'show-in-explorer', label: 'åœ¨æ–‡ä»¶ç®¡ç†å™¨ä¸­æ˜¾ç¤º', icon: 'ğŸ”' }
    ]
  }
}
```

#### å†…è”ç¼–è¾‘ç»„ä»¶

```typescript
// src/renderer/components/InlineEditor.tsx

import React, { useState, useRef, useEffect } from 'react'

interface InlineEditorProps {
  initialValue: string
  onSave: (newValue: string) => Promise<void>
  onCancel: () => void
  placeholder?: string
}

export const InlineEditor: React.FC<InlineEditorProps> = ({
  initialValue,
  onSave,
  onCancel,
  placeholder = ''
}) => {
  const [value, setValue] = useState(initialValue)
  const [isLoading, setIsLoading] = useState(false)
  const inputRef = useRef<HTMLInputElement>(null)

  useEffect(() => {
    if (inputRef.current) {
      inputRef.current.focus()
      inputRef.current.select()
    }
  }, [])

  const handleSave = async () => {
    if (!value.trim()) {
      onCancel()
      return
    }

    if (value === initialValue) {
      onCancel()
      return
    }

    setIsLoading(true)
    try {
      await onSave(value.trim())
    } catch (error) {
      console.error('ä¿å­˜å¤±è´¥:', error)
      // è¿™é‡Œå¯ä»¥æ˜¾ç¤ºé”™è¯¯æç¤º
    } finally {
      setIsLoading(false)
    }
  }

  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault()
      handleSave()
    } else if (e.key === 'Escape') {
      e.preventDefault()
      onCancel()
    }
  }

  return (
    <input
      ref={inputRef}
      type="text"
      value={value}
      onChange={(e) => setValue(e.target.value)}
      onKeyDown={handleKeyDown}
      onBlur={handleSave}
      placeholder={placeholder}
      disabled={isLoading}
      className="w-full px-1 py-0 text-sm bg-white dark:bg-gray-800 border border-blue-500 rounded focus:outline-none"
    />
  )
}
```

## ğŸ›¡ï¸ é”™è¯¯å¤„ç†å’ŒéªŒè¯

### æ–‡ä»¶åéªŒè¯

```typescript
// src/renderer/utils/fileValidation.ts

export const validateFileName = (name: string): string | null => {
  if (!name.trim()) {
    return 'æ–‡ä»¶åä¸èƒ½ä¸ºç©º'
  }

  if (name.trim() !== name) {
    return 'æ–‡ä»¶åä¸èƒ½ä»¥ç©ºæ ¼å¼€å¤´æˆ–ç»“å°¾'
  }

  // Windows å’Œ macOS éƒ½ä¸å…è®¸çš„å­—ç¬¦
  const invalidChars = /[<>:"/\\|?*]/
  if (invalidChars.test(name)) {
    return 'æ–‡ä»¶åä¸èƒ½åŒ…å«ä»¥ä¸‹å­—ç¬¦: < > : " / \\ | ? *'
  }

  // Windows ä¿ç•™åç§°
  const reservedNames = [
    'CON',
    'PRN',
    'AUX',
    'NUL',
    'COM1',
    'COM2',
    'COM3',
    'COM4',
    'COM5',
    'COM6',
    'COM7',
    'COM8',
    'COM9',
    'LPT1',
    'LPT2',
    'LPT3',
    'LPT4',
    'LPT5',
    'LPT6',
    'LPT7',
    'LPT8',
    'LPT9',
  ]
  if (reservedNames.includes(name.toUpperCase())) {
    return 'æ–‡ä»¶åä¸èƒ½ä½¿ç”¨ç³»ç»Ÿä¿ç•™åç§°'
  }

  if (name.length > 255) {
    return 'æ–‡ä»¶åè¿‡é•¿ï¼ˆæœ€å¤š255ä¸ªå­—ç¬¦ï¼‰'
  }

  return null
}

export const generateUniqueFileName = async (
  basePath: string,
  fileName: string
): Promise<string> => {
  let counter = 1
  let newName = fileName

  while (
    await window.electronAPI.invoke('file:exists', path.join(basePath, newName))
  ) {
    const ext = path.extname(fileName)
    const nameWithoutExt = path.basename(fileName, ext)
    newName = `${nameWithoutExt} (${counter})${ext}`
    counter++
  }

  return newName
}
```

### æƒé™æ£€æŸ¥

```typescript
// src/main/utils/permissions.ts

import * as fs from 'fs/promises'

export const checkPermissions = async (
  path: string,
  operation: 'read' | 'write' | 'delete'
): Promise<{ hasPermission: boolean; error?: string }> => {
  try {
    await fs.access(path, fs.constants.F_OK)

    switch (operation) {
      case 'read':
        await fs.access(path, fs.constants.R_OK)
        break
      case 'write':
        await fs.access(path, fs.constants.W_OK)
        break
      case 'delete':
        const parentDir = path.dirname(path)
        await fs.access(parentDir, fs.constants.W_OK)
        break
    }

    return { hasPermission: true }
  } catch (error) {
    return {
      hasPermission: false,
      error: `æ²¡æœ‰${operation === 'read' ? 'è¯»å–' : operation === 'write' ? 'å†™å…¥' : 'åˆ é™¤'}æƒé™`,
    }
  }
}
```

## ğŸ§ª æµ‹è¯•ç”¨ä¾‹

### å•å…ƒæµ‹è¯•

```typescript
// src/main/services/__tests__/fileService.test.ts

describe('FileService', () => {
  let fileService: FileService
  let tempDir: string

  beforeEach(async () => {
    fileService = new FileService()
    tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'jetide-test-'))
  })

  afterEach(async () => {
    await fs.rmdir(tempDir, { recursive: true })
  })

  describe('createFile', () => {
    it('should create a new file successfully', async () => {
      const result = await fileService.createFile(tempDir, 'test.txt')

      expect(result.success).toBe(true)
      expect(result.data.path).toBe(path.join(tempDir, 'test.txt'))

      const exists = await fs
        .access(path.join(tempDir, 'test.txt'))
        .then(() => true)
        .catch(() => false)
      expect(exists).toBe(true)
    })

    it('should fail when file already exists', async () => {
      await fs.writeFile(path.join(tempDir, 'existing.txt'), '')

      const result = await fileService.createFile(tempDir, 'existing.txt')

      expect(result.success).toBe(false)
      expect(result.error).toBe('æ–‡ä»¶å·²å­˜åœ¨')
    })
  })

  // ... æ›´å¤šæµ‹è¯•ç”¨ä¾‹
})
```

### é›†æˆæµ‹è¯•åœºæ™¯

1. **æ­£å¸¸æ“ä½œæµç¨‹**ï¼šåˆ›å»º â†’ é‡å‘½å â†’ åˆ é™¤
2. **é”™è¯¯å¤„ç†**ï¼šæƒé™ä¸è¶³ã€æ–‡ä»¶åå†²çªã€ç£ç›˜ç©ºé—´ä¸è¶³
3. **è¾¹ç•Œæƒ…å†µ**ï¼šè¶…é•¿æ–‡ä»¶åã€ç‰¹æ®Šå­—ç¬¦ã€ç³»ç»Ÿä¿ç•™åç§°
4. **å¹¶å‘æ“ä½œ**ï¼šåŒæ—¶è¿›è¡Œå¤šä¸ªæ–‡ä»¶æ“ä½œ

## ğŸ“ˆ æ€§èƒ½è€ƒè™‘

### ä¼˜åŒ–ç­–ç•¥

1. **æ‰¹é‡æ“ä½œ**ï¼šæ”¯æŒå¤šé€‰æ–‡ä»¶è¿›è¡Œæ‰¹é‡åˆ é™¤
2. **å¼‚æ­¥å¤„ç†**ï¼šæ‰€æœ‰æ–‡ä»¶æ“ä½œéƒ½æ˜¯å¼‚æ­¥çš„ï¼Œä¸é˜»å¡ UI
3. **ç¼“å­˜æœºåˆ¶**ï¼šç¼“å­˜æ–‡ä»¶æ ‘çŠ¶æ€ï¼Œå‡å°‘é‡å¤è¯»å–
4. **æ‡’åŠ è½½**ï¼šå¤§æ–‡ä»¶å¤¹å»¶è¿ŸåŠ è½½å­é¡¹

### æ€§èƒ½æŒ‡æ ‡

- å•ä¸ªæ–‡ä»¶æ“ä½œå“åº”æ—¶é—´ < 100ms
- æ‰¹é‡æ“ä½œï¼ˆ100ä¸ªæ–‡ä»¶ï¼‰< 5s
- UI å“åº”æ—¶é—´ < 50ms

## ğŸš€ å®æ–½è®¡åˆ’

### Day 1: åŸºç¡€æ¶æ„

- [ ] è®¾è®¡å¹¶å®ç° IPC æ¥å£
- [ ] åˆ›å»ºä¸»è¿›ç¨‹æ–‡ä»¶æœåŠ¡
- [ ] å®ç°åŸºç¡€çš„æ–‡ä»¶æ“ä½œï¼ˆåˆ›å»ºã€åˆ é™¤ã€é‡å‘½åï¼‰

### Day 2: UI ç»„ä»¶å’Œé›†æˆ

- [ ] å®ç°å³é”®èœå•ç»„ä»¶
- [ ] å®ç°å†…è”ç¼–è¾‘ç»„ä»¶
- [ ] é›†æˆåˆ°æ–‡ä»¶æ ‘ç»„ä»¶
- [ ] æ·»åŠ é”™è¯¯å¤„ç†å’Œç”¨æˆ·åé¦ˆ

## ğŸ¯ éªŒæ”¶æ ‡å‡†

### åŠŸèƒ½éªŒæ”¶

- [ ] èƒ½å¤Ÿé€šè¿‡å³é”®èœå•åˆ›å»ºæ–‡ä»¶å’Œæ–‡ä»¶å¤¹
- [ ] èƒ½å¤Ÿé‡å‘½åæ–‡ä»¶å’Œæ–‡ä»¶å¤¹
- [ ] èƒ½å¤Ÿåˆ é™¤æ–‡ä»¶å’Œæ–‡ä»¶å¤¹
- [ ] æ‰€æœ‰æ“ä½œéƒ½æœ‰é€‚å½“çš„é”™è¯¯å¤„ç†
- [ ] æ–‡ä»¶æ ‘èƒ½å¤Ÿå®æ—¶æ›´æ–°

### ç”¨æˆ·ä½“éªŒéªŒæ”¶

- [ ] æ“ä½œå“åº”è¿…é€Ÿï¼ˆ< 100msï¼‰
- [ ] é”™è¯¯æç¤ºæ¸…æ™°å‹å¥½
- [ ] æ”¯æŒé”®ç›˜æ“ä½œï¼ˆEnter ç¡®è®¤ï¼ŒEsc å–æ¶ˆï¼‰
- [ ] è§†è§‰åé¦ˆæ˜ç¡®ï¼ˆåŠ è½½çŠ¶æ€ã€æˆåŠŸæç¤ºï¼‰

### ä»£ç è´¨é‡éªŒæ”¶

- [ ] ä»£ç æœ‰å®Œæ•´çš„ TypeScript ç±»å‹æ³¨è§£
- [ ] å…³é”®åŠŸèƒ½æœ‰å•å…ƒæµ‹è¯•è¦†ç›–
- [ ] éµå¾ªé¡¹ç›®çš„ä»£ç è§„èŒƒ
- [ ] æœ‰é€‚å½“çš„é”™è¯¯è¾¹ç•Œå¤„ç†

---

**ä¸‹ä¸€æ­¥**: å®ç°æ–‡ä»¶æœç´¢å’Œå¯¼èˆªåŠŸèƒ½ â†’ [02-file-search.md](./02-file-search.md)
